@{
    ViewData["Title"] = "–¢–≤–æ–µ—Ç–æ –º–µ–¥–µ–Ω–æ –∫—ä—Å–º–µ—Ç—á–µ";
}

<!-- Main Container -->
<div class="honey-fortune-container" style="min-height: 100vh; background: linear-gradient(135deg, #FFF8E7 0%, #FFE5B4 50%, #FFD89B 100%); padding: 40px 20px; position: relative; overflow-x: hidden;">
    
    <!-- Honeycomb Background Decoration -->
    <div class="honeycomb-bg" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0.03; pointer-events: none; z-index: 0;">
        <div style="position: absolute; top: 10%; left: 5%; width: 100px; height: 87px; background: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 87\"><polygon points=\"50,0 93.3,25 93.3,75 50,100 6.7,75 6.7,25\" fill=\"%23F59F0A\" opacity=\"0.1\"/></svg>') no-repeat; background-size: contain; animation: float 20s infinite ease-in-out;"></div>
        <div style="position: absolute; top: 60%; right: 10%; width: 80px; height: 70px; background: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 87\"><polygon points=\"50,0 93.3,25 93.3,75 50,100 6.7,75 6.7,25\" fill=\"%23F59F0A\" opacity=\"0.1\"/></svg>') no-repeat; background-size: contain; animation: float 25s infinite ease-in-out reverse;"></div>
        <div style="position: absolute; bottom: 15%; left: 15%; width: 60px; height: 52px; background: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 87\"><polygon points=\"50,0 93.3,25 93.3,75 50,100 6.7,75 6.7,25\" fill=\"%23F59F0A\" opacity=\"0.1\"/></svg>') no-repeat; background-size: contain; animation: float 18s infinite ease-in-out;"></div>
    </div>

    <div class="container" style="position: relative; z-index: 1; max-width: 600px; margin: 0 auto;">
        <!-- Header Section -->
        <header class="fortune-header" style="text-align: center; margin-bottom: 2rem;">
            <h1 style="font-size: 2.5rem; font-weight: 700; color: #D97706; margin-bottom: 1rem; text-shadow: 2px 2px 4px rgba(0,0,0,0.1);">
                üçØ –¢–≤–æ–µ—Ç–æ –º–µ–¥–µ–Ω–æ –∫—ä—Å–º–µ—Ç—á–µ
            </h1>
        </header>

        @if (ViewBag.CanAccessFortune == false)
        {
            <!-- Message for users who already got fortune today -->
            <div class="fortune-message" style="text-align: center; padding: 1.5rem 2rem; margin-bottom: 2rem; background: linear-gradient(135deg, #FFF8E7 0%, #FFE5B4 100%); border-radius: 16px; box-shadow: 0 5px 20px rgba(0,0,0,0.1); max-width: 600px; margin-left: auto; margin-right: auto;">
                <div style="font-size: 1.2rem; color: #5A3E1F; line-height: 1.6; font-weight: 600;">
                    –¢–æ–≤–∞ –µ —Ç–≤–æ–µ—Ç–æ –∫—ä—Å–º–µ—Ç—á–µ –∑–∞ –¥–Ω–µ—Å, –≤—ä—Ä–Ω–∏ —Å–µ —É—Ç—Ä–µ –æ—Ç–Ω–æ–≤–æ, –∑–∞ –¥–∞ –≤–∏–¥–∏—à –∫—ä—Å–º–µ—Ç—á–µ—Ç–æ —Å–∏ –∑–∞ –¥–µ–Ω—è.
                </div>
            </div>
        }
        
        <!-- Scratch Card Section (always shown, with stored fortune) -->
        @if (ViewBag.FortuneText != null)
        {
            <section id="scratchSection" class="scratch-section" aria-live="polite">
            <div class="scratch-card-wrapper" id="cardWrapper" style="perspective: 1000px; width: 100%; max-width: 520px; margin: 0 auto; position: relative; cursor: pointer;">
                <div id="cardContainer" class="card-container" style="position: relative; width: 100%; height: 100%; min-height: 300px; transform-style: preserve-3d; transition: transform 0.6s ease-in-out;">
                    <!-- Front of card -->
                    <div class="scratch-card" id="scratchCardFront" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; min-height: 300px; background: linear-gradient(135deg, #FFF8E7 0%, #FFE5B4 100%); border-radius: 24px; box-shadow: 0 10px 40px rgba(0,0,0,0.15); overflow: hidden; padding: 2rem; backface-visibility: hidden; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                        <!-- Fortune text (visible under canvas) -->
                        <div class="fortune-text" id="fortuneText" style="position: relative; z-index: 1; text-align: center; font-size: 1.6rem; line-height: 1.8; color: #5A3E1F; padding: 1.5rem; font-weight: 600; width: 100%; display: flex; align-items: center; justify-content: center; min-height: 200px;"></div>
                        
                        <!-- Art Cafe Logo -->
                        <div class="art-cafe-logo" style="position: absolute; bottom: 15px; right: 15px; z-index: 1; opacity: 0.4; pointer-events: none;">
                            <img src="~/Uploads/WebsiteAnimations/art-cafe-logo.png" alt="Art Cafe Logo" style="width: 104px; height: auto; max-width: 100%;" />
                        </div>
                        
                        <!-- Canvas for scratch layer -->
                        <canvas id="scratchCanvas" class="scratch-canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; cursor: crosshair; z-index: 2; border-radius: 24px; touch-action: none; pointer-events: auto;"></canvas>
                    </div>
                    
                    <!-- Back of card (golden with Save the Bee logo) -->
                    <div id="scratchCardBack" class="scratch-card-back" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; min-height: 300px; background: linear-gradient(135deg, #F59F0A 0%, #D97706 50%, #B45309 100%); border-radius: 24px; box-shadow: 0 10px 40px rgba(0,0,0,0.15); display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 0.5rem; backface-visibility: hidden; transform: rotateY(180deg); cursor: pointer; pointer-events: auto; overflow: hidden;">
                        <img src="~/Uploads/WebsiteAnimations/save-the-bee-logo.png" alt="Save the Bee" class="card-back-logo" style="width: 100%; height: auto; max-height: 85%; object-fit: contain; pointer-events: none; filter: brightness(1.2) contrast(1.3); display: block; margin: 0 auto; transform: scale(1.5);" />
                    </div>
                </div>
                
                <!-- Invisible hand animation element -->
                <div id="scratchHand" class="scratch-hand" aria-hidden="true" style="position: absolute; width: 50px; height: 50px; z-index: 3; pointer-events: none; opacity: 0; transition: opacity 0.3s; top: 0; left: 0;">
                    <svg width="50" height="50" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 2L2 7L12 12L22 7L12 2Z" fill="#F59F0A" stroke="#D97706" stroke-width="1.5"/>
                        <path d="M2 17L12 22L22 17" stroke="#D97706" stroke-width="1.5"/>
                        <path d="M2 12L12 17L22 12" stroke="#D97706" stroke-width="1.5"/>
                    </svg>
                </div>
            </div>
            
            <!-- Flying Bee Animation -->
            <div id="flyingBee" class="flying-bee" aria-hidden="true" style="position: fixed; top: 0; left: 0; width: 80px; height: 80px; z-index: 1000; pointer-events: none; opacity: 0; transform: translateX(-100px);">
                <img src="~/Uploads/WebsiteAnimations/small-bee-for-animation.png" alt="Flying bee" style="width: 100%; height: 100%; object-fit: contain;" />
            </div>
        </section>
        }
    </div>
</div>

<style>
    /* Screen reader only */
    .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border-width: 0;
    }

    /* Input focus styles */
    .code-input:focus {
        outline: none;
        border-color: #D97706 !important;
        box-shadow: 0 0 0 4px rgba(245, 159, 10, 0.1);
        transform: scale(1.02);
    }

    .code-input.shake {
        animation: shake 0.5s;
    }

    @@keyframes shake {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-10px); }
        75% { transform: translateX(10px); }
    }

    /* Button hover and disabled states */
    .reveal-btn:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(245, 159, 10, 0.4);
    }

    .reveal-btn:active:not(:disabled) {
        transform: translateY(0);
    }

    .reveal-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        background: #ccc !important;
    }

    /* Scratch section animation */
    .scratch-section {
        animation: fadeInScale 0.5s ease-out;
    }

    @@keyframes fadeInScale {
        from {
            opacity: 0;
            transform: scale(0.95);
        }
        to {
            opacity: 1;
            transform: scale(1);
        }
    }

    /* Honeycomb float animation */
    @@keyframes float {
        0%, 100% {
            transform: translateY(0) rotate(0deg);
        }
        50% {
            transform: translateY(-20px) rotate(5deg);
        }
    }

    /* Flying Bee Animation */
    .flying-bee {
        transition: opacity 0.5s ease-in-out;
    }
    
    /* Subtle bee hover/flutter animation */
    @@keyframes beeFlutter {
        0%, 100% {
            transform: translateY(0) rotate(0deg);
        }
        25% {
            transform: translateY(-3px) rotate(2deg);
        }
        75% {
            transform: translateY(3px) rotate(-2deg);
        }
    }
    
    .flying-bee.active img {
        animation: beeFlutter 0.3s ease-in-out infinite;
    }
    
    @@keyframes beeFly {
        0% {
            transform: translateX(-100px) translateY(0) rotate(-5deg);
            opacity: 1;
        }
        10% {
            transform: translateX(10vw) translateY(-20px) rotate(2deg);
        }
        25% {
            transform: translateX(25vw) translateY(-35px) rotate(-3deg);
        }
        40% {
            transform: translateX(40vw) translateY(-10px) rotate(4deg);
        }
        50% {
            transform: translateX(50vw) translateY(15px) rotate(-2deg);
        }
        65% {
            transform: translateX(65vw) translateY(-5px) rotate(3deg);
        }
        75% {
            transform: translateX(75vw) translateY(-25px) rotate(-4deg);
        }
        90% {
            transform: translateX(90vw) translateY(-10px) rotate(2deg);
        }
        100% {
            transform: translateX(calc(100vw + 100px)) translateY(0) rotate(-5deg);
            opacity: 0;
        }
    }
    
    .flying-bee.active {
        animation: beeFly 4s ease-in-out forwards;
    }

    /* Prevent scrolling on mobile when scratching */
    .scratch-canvas {
        touch-action: none;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
    }
    
    .scratch-section {
        position: relative;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1;
        padding: 2rem 0;
        touch-action: none;
    }
    
    /* Prevent body scroll only when actively scratching on mobile */
    body.scratching-active {
        overflow: hidden;
        position: fixed;
        width: 100%;
        height: 100%;
    }
    
    /* Ensure navigation is always visible */
    .honey-fortune-container {
        position: relative;
        z-index: 1;
    }
    
    .scratch-card-wrapper {
        width: 90%;
        max-width: 520px;
    }
    
    /* Card flip animation */
    .card-container {
        position: relative;
        width: 100%;
        min-height: 300px;
    }
    
    .card-container.flipped {
        transform: rotateY(180deg);
    }
    
    .scratch-card,
    .scratch-card-back {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
    }
    
    .scratch-card {
        transform: rotateY(0deg);
    }
    
    .scratch-card-back {
        transform: rotateY(180deg);
    }
    
    /* Pulse animation for flip hint */
    @@keyframes pulse {
        0%, 100% {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }
        50% {
            transform: translate(-50%, -50%) scale(1.05);
            opacity: 0.9;
        }
    }
    
    /* Responsive design */
    @@media (max-width: 768px) {
        .honey-fortune-container {
            padding: 20px 10px !important;
        }
        
        .honey-fortune-container h1 {
            font-size: 1.8rem !important;
            margin-bottom: 1rem !important;
        }
        
        .scratch-section {
            padding: 20px 10px;
        }
        
        .scratch-card {
            padding: 1.5rem !important;
            min-height: 280px !important;
        }
        
        .art-cafe-logo {
            bottom: 10px !important;
            right: 10px !important;
        }
        
        .art-cafe-logo img {
            width: 81px !important;
        }
        
        .fortune-text {
            font-size: 1.4rem !important;
            line-height: 1.7 !important;
            padding: 1rem !important;
            min-height: 180px !important;
        }
        
        .scratch-card-back {
            padding: 0.5rem !important;
            min-height: 280px !important;
        }
        
        .card-back-logo {
            width: 100% !important;
            max-height: 85% !important;
            transform: scale(1.5) !important;
        }
    }
    
    @@media (max-width: 480px) {
        .scratch-card {
            padding: 1.25rem !important;
            min-height: 250px !important;
        }
        
        .scratch-card-back {
            min-height: 250px !important;
            padding: 0.5rem !important;
        }
        
        .card-back-logo {
            width: 100% !important;
            max-height: 85% !important;
            transform: scale(1.5) !important;
        }
        
        .fortune-text {
            font-size: 1.2rem !important;
            line-height: 1.6 !important;
            min-height: 150px !important;
        }
        
        .art-cafe-logo img {
            width: 70px !important;
        }
    }
</style>

<script>
    // Get the fortune from server (stored per IP per day)
    @{
        string fortuneJs = "null";
        if (ViewBag.FortuneText != null)
        {
            // Escape the fortune text for JavaScript
            fortuneJs = "\"" + ViewBag.FortuneText.ToString()
                .Replace("\\", "\\\\")
                .Replace("\"", "\\\"")
                .Replace("\r", "")
                .Replace("\n", " ")
                .Replace("'", "\\'") + "\"";
        }
    }
    const serverFortune = @Html.Raw(fortuneJs);

    // DOM Elements
    let scratchSection, fortuneText, scratchCanvas, scratchHand, flyingBee, cardContainer, cardWrapper;
    let ctx, isScratching = false, hasScratched = false, autoScratchComplete = false;
    let beeAnimationTriggered = false;
    let isFullyScratched = false;
    let cardFlipped = false;

    // Global click handler for card flip
    function setupCardFlipHandlers() {
        if (!cardWrapper || !cardContainer) return;
        
        // Remove any existing handlers first
        const newWrapperClick = function(e) {
            e.preventDefault();
            e.stopPropagation();
            console.log('üîÑ Card wrapper clicked - toggling card');
            flipCard(e);
            return false;
        };
        
        const newContainerClick = function(e) {
            e.preventDefault();
            e.stopPropagation();
            console.log('üîÑ Card container clicked - toggling card');
            flipCard(e);
            return false;
        };
        
        const newBackClick = function(e) {
            e.preventDefault();
            e.stopPropagation();
            console.log('üîÑ Card back clicked - toggling card');
            flipCard(e);
            return false;
        };
        
        // Setup wrapper handlers
        cardWrapper.onclick = newWrapperClick;
        cardWrapper.ontouchend = function(e) {
            e.preventDefault();
            e.stopPropagation();
            flipCard(e);
            return false;
        };
        
        // Setup container handlers
        cardContainer.onclick = newContainerClick;
        cardContainer.ontouchend = function(e) {
            e.preventDefault();
            e.stopPropagation();
            flipCard(e);
            return false;
        };
        
        // Setup back card handlers
        const cardBack = document.getElementById('scratchCardBack');
        if (cardBack) {
            cardBack.onclick = newBackClick;
            cardBack.ontouchend = function(e) {
                e.preventDefault();
                e.stopPropagation();
                flipCard(e);
                return false;
            };
        }
    }

    // Initialization
    function init() {
        scratchSection = document.getElementById('scratchSection');
        fortuneText = document.getElementById('fortuneText');
        scratchCanvas = document.getElementById('scratchCanvas');
        scratchHand = document.getElementById('scratchHand');
        flyingBee = document.getElementById('flyingBee');
        cardContainer = document.getElementById('cardContainer');
        cardWrapper = document.getElementById('cardWrapper');
        
        // Setup flip handlers immediately (they'll only work when card is ready)
        setupCardFlipHandlers();

        // Prevent scrolling on mobile when touching canvas
        let isScratching = false;
        
        scratchCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            isScratching = true;
            document.body.classList.add('scratching-active');
        }, { passive: false });
        
        scratchCanvas.addEventListener('touchmove', (e) => {
            if (isScratching) {
                e.preventDefault();
                e.stopPropagation();
            }
        }, { passive: false });
        
        scratchCanvas.addEventListener('touchend', (e) => {
            isScratching = false;
            setTimeout(() => {
                document.body.classList.remove('scratching-active');
            }, 100);
        }, { passive: false });
        
        scratchCanvas.addEventListener('touchcancel', (e) => {
            isScratching = false;
            document.body.classList.remove('scratching-active');
        }, { passive: false });

        // Use the fortune from server (same fortune per IP per day)
        // If serverFortune is null, fallback to a default message (shouldn't happen in normal flow)
        const fortuneToShow = serverFortune || "–ö—ä—Å–º–µ—Ç! –î–Ω–µ—Å —â–µ —Å–µ —Å–ª—É—á–∏ –Ω–µ—â–æ, –∫–æ–µ—Ç–æ —â–µ —Ç–µ –∑–∞—Ä–∞–¥–≤–∞.";
        showScratchCard(fortuneToShow);
    }

    // Show scratch card
    function showScratchCard(fortune) {
        fortuneText.textContent = fortune;
        scratchSection.style.display = 'flex';
        
        // Reset flags
        beeAnimationTriggered = false;
        isFullyScratched = false;
        cardFlipped = false;
        
        // Initialize canvas
        setTimeout(() => {
            initScratchCanvas();
            // Start auto-scratch animation
            setTimeout(() => {
                startAutoScratch();
            }, 500);
        }, 100);
    }

    // Initialize canvas
    function initScratchCanvas() {
        const card = scratchCanvas.parentElement;
        const rect = card.getBoundingClientRect();
        
        scratchCanvas.width = rect.width;
        scratchCanvas.height = rect.height;
        
        // Optimize for frequent readback operations (for scratch progress checking)
        ctx = scratchCanvas.getContext('2d', { willReadFrequently: true });
        
        // Draw scratch cover (golden gradient)
        const gradient = ctx.createLinearGradient(0, 0, rect.width, rect.height);
        gradient.addColorStop(0, '#F59F0A');
        gradient.addColorStop(0.5, '#D97706');
        gradient.addColorStop(1, '#B45309');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, rect.width, rect.height);
        
        // Add subtle texture pattern
        ctx.globalCompositeOperation = 'multiply';
        ctx.fillStyle = 'rgba(139, 69, 19, 0.1)';
        for (let i = 0; i < 50; i++) {
            ctx.fillRect(
                Math.random() * rect.width,
                Math.random() * rect.height,
                20,
                20
            );
        }
        ctx.globalCompositeOperation = 'source-over';
    }
    
    // Throttle the check to avoid too frequent calls
    let lastCheckTime = 0;
    let lastProgressCheckTime = 0;
    const CHECK_THROTTLE = 200; // Check every 200ms max to reduce getImageData calls (reduced for faster detection)
    const PROGRESS_CHECK_THROTTLE = 100; // Check progress every 100ms (more frequent for better detection)
    
    // Check if card is fully scratched and enable flip
    function checkIfFullyScratched() {
        if (isFullyScratched || cardFlipped) return;
        
        // Throttle the check
        const now = Date.now();
        if (now - lastCheckTime < CHECK_THROTTLE) return;
        lastCheckTime = now;
        
        if (!ctx || !scratchCanvas) return;
        
        try {
            const imageData = ctx.getImageData(0, 0, scratchCanvas.width, scratchCanvas.height);
            const pixels = imageData.data;
            let transparentPixels = 0;
            const totalPixels = pixels.length / 4;
            
            // Count transparent pixels
            for (let i = 3; i < pixels.length; i += 4) {
                if (pixels[i] === 0) {
                    transparentPixels++;
                }
            }
            
            const scratchedPercentage = (transparentPixels / totalPixels) * 100;
            
            // Log progress for debugging
            if (scratchedPercentage > 50 && !isFullyScratched) {
                console.log(`üìä Card is ${scratchedPercentage.toFixed(1)}% scratched`);
            }
            
            // If more than 60% is scratched, enable flip (lowered threshold)
            if (scratchedPercentage > 60 && !isFullyScratched) {
                isFullyScratched = true;
                console.log(`‚úÖ Card is ${scratchedPercentage.toFixed(1)}% scratched - ENABLING FLIP`);
                
                // Disable canvas pointer events for scratching, but keep it visible
                scratchCanvas.style.pointerEvents = 'none';
                scratchCanvas.style.cursor = 'pointer';
                scratchCanvas.style.opacity = '0.1';
                scratchCanvas.style.transition = 'opacity 0.3s ease';
                
                // Enable card flip handlers (they're already set up in init)
                if (cardWrapper) {
                    cardWrapper.style.cursor = 'pointer';
                    cardWrapper.style.pointerEvents = 'auto';
                }
                
                if (cardContainer) {
                    cardContainer.style.cursor = 'pointer';
                    cardContainer.style.pointerEvents = 'auto';
                }
                
                // Make the back of the card clickable
                const cardBack = document.getElementById('scratchCardBack');
                if (cardBack) {
                    cardBack.style.cursor = 'pointer';
                    cardBack.style.pointerEvents = 'auto';
                }
                
                // Re-setup handlers to ensure they're active
                setupCardFlipHandlers();
                
                console.log('‚úÖ Card is ready to flip! Click anywhere on the card to flip.');
            }
        } catch (error) {
            console.error('Error checking scratch progress:', error);
        }
    }
    
    // Flip card to toggle between front and back
    function flipCard(e) {
        if (e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        // Only allow flip if card is fully scratched (unless already flipped, then allow toggle)
        if (!isFullyScratched && !cardFlipped) {
            // Double-check the scratch percentage before denying
            if (ctx && scratchCanvas) {
                try {
                    const imageData = ctx.getImageData(0, 0, scratchCanvas.width, scratchCanvas.height);
                    const pixels = imageData.data;
                    let transparentPixels = 0;
                    const totalPixels = pixels.length / 4;
                    
                    for (let i = 3; i < pixels.length; i += 4) {
                        if (pixels[i] === 0) {
                            transparentPixels++;
                        }
                    }
                    
                    const scratchedPercentage = (transparentPixels / totalPixels) * 100;
                    console.log(`üîç Re-checking: Card is ${scratchedPercentage.toFixed(1)}% scratched`);
                    
                    if (scratchedPercentage > 60) {
                        console.log('‚úÖ Actually ready to flip! Enabling now...');
                        isFullyScratched = true;
                        // Continue with flip
                    } else {
                        console.log(`‚ö†Ô∏è Card not fully scratched yet (${scratchedPercentage.toFixed(1)}%) - cannot flip`);
                        return false;
                    }
                } catch (error) {
                    console.error('Error re-checking scratch:', error);
                    return false;
                }
            } else {
                console.log('‚ö†Ô∏è Card not fully scratched yet - cannot flip (no context)');
                return false;
            }
        }
        
        console.log('üîÑ Toggling card flip...');
        isDrawing = false;
        
        // Toggle the flipped state
        cardFlipped = !cardFlipped;
        
        // Hide/show canvas based on flip state
        if (scratchCanvas) {
            if (cardFlipped) {
                scratchCanvas.style.display = 'none';
            } else {
                scratchCanvas.style.display = 'block';
                scratchCanvas.style.opacity = '0.1';
                scratchCanvas.style.pointerEvents = 'none';
            }
        }
        
        // Toggle the flipped class
        if (cardContainer) {
            if (cardFlipped) {
                console.log('‚úÖ Flipping to back');
                cardContainer.classList.add('flipped');
                
                // Ensure back is clickable when flipped
                const cardBack = document.getElementById('scratchCardBack');
                if (cardBack) {
                    cardBack.style.pointerEvents = 'auto';
                    cardBack.style.cursor = 'pointer';
                }
            } else {
                console.log('‚úÖ Flipping back to front');
                cardContainer.classList.remove('flipped');
            }
        } else {
            console.error('‚ùå cardContainer not found!');
        }
        
        return false;
    }

    // Check scratch progress and trigger bee animation
    function checkScratchProgress() {
        if (beeAnimationTriggered) return;
        
        const imageData = ctx.getImageData(0, 0, scratchCanvas.width, scratchCanvas.height);
        const pixels = imageData.data;
        let transparentPixels = 0;
        const totalPixels = pixels.length / 4;
        
        // Count transparent pixels
        for (let i = 3; i < pixels.length; i += 4) {
            if (pixels[i] === 0) {
                transparentPixels++;
            }
        }
        
        const scratchedPercentage = (transparentPixels / totalPixels) * 100;
        
        // If more than 60% is scratched, trigger bee animation
        if (scratchedPercentage > 60) {
            triggerBeeAnimation();
            beeAnimationTriggered = true;
        }
        
        // Check if fully scratched for flip functionality
        checkIfFullyScratched();
    }

    // Trigger bee animation
    function triggerBeeAnimation() {
        // Position bee on the left side of screen
        const randomY = Math.random() * (window.innerHeight * 0.6) + (window.innerHeight * 0.2);
        flyingBee.style.top = randomY + 'px';
        flyingBee.style.opacity = '1';
        
        // Add animation class
        flyingBee.classList.add('active');
        
        // Remove class after animation
        setTimeout(() => {
            flyingBee.classList.remove('active');
            flyingBee.style.opacity = '0';
        }, 3000);
    }

    // Auto-scratch animation (invisible hand)
    function startAutoScratch() {
        const card = scratchCanvas.parentElement;
        const cardWrapper = scratchHand.parentElement;
        const rect = card.getBoundingClientRect();
        const wrapperRect = cardWrapper.getBoundingClientRect();
        
        // Define trajectory (fewer lines for bigger brush)
        const paths = [
            { start: { x: rect.width * 0.1, y: rect.height * 0.3 }, end: { x: rect.width * 0.9, y: rect.height * 0.4 } },
            { start: { x: rect.width * 0.2, y: rect.height * 0.6 }, end: { x: rect.width * 0.8, y: rect.height * 0.7 } }
        ];

        let currentPath = 0;
        let progress = 0;
        const brushSize = 150; // Much larger brush size
        
        scratchHand.style.opacity = '1';
        
        function animate() {
            if (currentPath >= paths.length) {
                scratchHand.style.opacity = '0';
                autoScratchComplete = true;
                enableManualScratch();
                return;
            }

            const path = paths[currentPath];
            const x = path.start.x + (path.end.x - path.start.x) * progress;
            const y = path.start.y + (path.end.y - path.start.y) * progress;

            // Position "hand" relative to card wrapper
            scratchHand.style.left = (rect.left - wrapperRect.left + x - 25) + 'px';
            scratchHand.style.top = (rect.top - wrapperRect.top + y - 25) + 'px';

            // Erase in canvas with much larger brush
            ctx.globalCompositeOperation = 'destination-out';
            ctx.beginPath();
            ctx.arc(x, y, brushSize / 2, 0, Math.PI * 2);
            ctx.fill();
            // Add additional circles for more effective erasing
            ctx.beginPath();
            ctx.arc(x - 10, y, brushSize / 2.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 10, y, brushSize / 2.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x, y - 10, brushSize / 2.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x, y + 10, brushSize / 2.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalCompositeOperation = 'source-over';
            
            // Check scratch progress (throttled)
            const now = Date.now();
            if (now - lastProgressCheckTime >= PROGRESS_CHECK_THROTTLE) {
                lastProgressCheckTime = now;
                checkScratchProgress();
            }

            progress += 0.04;
            
            if (progress >= 1) {
                progress = 0;
                currentPath++;
            }

            requestAnimationFrame(animate);
        }

        animate();
    }

    // Manual scratch
    let manualScratchEnabled = false;
    let isDrawing = false;
    let lastPoint = null;
    
    function enableManualScratch() {
        if (manualScratchEnabled) return;
        manualScratchEnabled = true;
        
        const brushSize = 150; // Much larger brush size for 2-3 gestures

        function getPoint(e) {
            const rect = scratchCanvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function draw(e) {
            if (!isDrawing || cardFlipped || isFullyScratched) return;
            
            const point = getPoint(e);
            
            ctx.globalCompositeOperation = 'destination-out';
            
            // Main circle - much larger
            ctx.beginPath();
            ctx.arc(point.x, point.y, brushSize / 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Additional circles for more effective erasing
            ctx.beginPath();
            ctx.arc(point.x - 15, point.y, brushSize / 2.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(point.x + 15, point.y, brushSize / 2.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(point.x, point.y - 15, brushSize / 2.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(point.x, point.y + 15, brushSize / 2.2, 0, Math.PI * 2);
            ctx.fill();
            
            // If there's a previous point, draw line between them for smooth erasing
            if (lastPoint) {
                ctx.beginPath();
                ctx.moveTo(lastPoint.x, lastPoint.y);
                ctx.lineTo(point.x, point.y);
                ctx.lineWidth = brushSize;
                ctx.lineCap = 'round';
                ctx.stroke();
            }
            
            lastPoint = point;
            ctx.globalCompositeOperation = 'source-over';
            
            // Check scratch progress (throttled)
            const now = Date.now();
            if (now - lastProgressCheckTime >= PROGRESS_CHECK_THROTTLE) {
                lastProgressCheckTime = now;
                checkScratchProgress();
            }
        }

        function handleStart(e) {
            if (cardFlipped) {
                // If flipped, let the flip handler take over
                return;
            }
            if (isFullyScratched) {
                // If fully scratched, don't handle here - let the wrapper handle it for flipping
                e.preventDefault();
                e.stopPropagation();
                return;
            }
            e.preventDefault();
            e.stopPropagation();
            isDrawing = true;
            lastPoint = getPoint(e);
            draw(e);
        }

        function handleMove(e) {
            if (cardFlipped || isFullyScratched) return;
            e.preventDefault();
            e.stopPropagation();
            draw(e);
        }

        function handleEnd(e) {
            if (isFullyScratched || cardFlipped) {
                // Don't handle end events if fully scratched - let wrapper handle clicks
                isDrawing = false;
                lastPoint = null;
                return;
            }
            isDrawing = false;
            lastPoint = null;
        }

        scratchCanvas.addEventListener('pointerdown', handleStart);
        scratchCanvas.addEventListener('pointermove', handleMove);
        scratchCanvas.addEventListener('pointerup', handleEnd);
        scratchCanvas.addEventListener('pointerleave', handleEnd);
        
        // Touch events for mobile
        scratchCanvas.addEventListener('touchstart', handleStart, { passive: false });
        scratchCanvas.addEventListener('touchmove', handleMove, { passive: false });
        scratchCanvas.addEventListener('touchend', handleEnd, { passive: false });
        scratchCanvas.addEventListener('touchcancel', handleEnd, { passive: false });
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', init);
</script>

